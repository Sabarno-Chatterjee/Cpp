C++ Standard Template Library 


-> <bits/stdc++.h> : Master library for competitive programming.

-> Components of STL:
                    * Algorithms
                    * Containers
                    * Functions
                    * Iterators

-> PAIR: It is a part of the utility library.

        Eg: pair<int,int> p= {1,3};

            cout<<p.first<<" "<<p.second;

        Eg: pair<int,pair<int,int>> p= {1,{3,4}};

            cout<<p.first<<" "<<p.second.first<<" "<<p.second.second;

        Eg: Array of pairs

            pair<int,pair<string,string>> name[]={
                {1,{"Harry","Potter"}},
                {2,{"Hemione","Granger"}},
                {3,{"Ronald","Weasley"}}
            };

            cout<<name[0].first<<" : "<<name[0].second.first<<" "<<name[0].second.second<<endl;
            cout<<name[1].first<<" : "<<name[1].second.first<<" "<<name[1].second.second<<endl;
            cout<<name[2].first<<" : "<<name[2].second.first<<" "<<name[2].second.second<<endl;


-> Containers

    # Vectors
        Vector is a container which is dynamic in nature and hence we can increase it's size as per our need. In case we are unsure about the size requirements, vector is a safe bet. It stores elements in a similar fashion as an array.

        Declaration: vector<data_type> data_type_name; 
                     [Creates an empty container]

                Eg 1: vector<int> v;
                     v.push_back(1);[Adds an element to the container]
                     v.emplace_back(2);[Dynamically increases the space and adds an element]

                     Generically emplace_back() is faster than push_back.

                Eg 2: vector<pair<int,int>> v1;
                      v1.push_back({4,5});
                      or 
                      v1.emplace_back(4,5); [Assumes it a pair and no need to entire the braces]

                Eg 3: vector<int> v2(5, 100); [Will initialize a vector v2;    with 5 instances of 100]


                Eg 4: vector<int> v3(v2); [Will copy vector v2 into v3]

        We can access the elements in a similar fashion as we access elements from an array. Eg: cout<<v[0];

        Vectors are same as dynamic arrays with the ability to resize itself automatically when an element is inserted or deleted, with their storage being handled automatically by the container.

        * vector::at()
                
                at() function is used reference the element present at the position given as the parameter to the function. 

                Eg: cout << v.at(3);

        * vector::erase()
                
                erase() function is used to remove elements from a container from the specified position or range.

            Syntax:
                vector_name.erase(position);    
                [for deletion at specific position]
                Eg: v.erase(v.begin()+1);


                vector_name.erase(starting_position, ending_position);    
                [for deletion in range, here the starting position is inclusive but the ending is not]
                Eg: v.erase(v.begin()+1,v.begin()+4);

        * insert() – it is used to insert an element at a specified position.

                Eg:
                auto it= v.begin();
                v.insert(it,5); //inserting 5 at the beginning
                v.insert(v.begin()+1,2,5); //inserting 2 instances of 5 after the first element

                [insert() is costly in a vector compared to a list]

        * pop_back() – it deletes the last element and returns it to the    calling function.

                v1.pop_back();

        * front() – it returns a reference to the first element of the vector.
                
                v1.front();

        * back() – it returns a reference to the last element of the vector.
                
                v1.back();
        * clear() – deletes all the elements from the vector.
                
                v1.clear();
        * empty() – to check if the vector is empty or not.
                
                v1.empty();
        * size() – returns the size of the vector
                
                v1.size();                    

-> Iterators



    Iterators are used to point at the memory addresses of STL containers. They are primarily used in sequences of numbers, characters etc. They reduce the complexity and execution time of the program.

    Operations of iterators :-

        1. begin() :- This function is used to return the beginning position of the container.

        2. end() :- This function is used to return the after end position of the container.

    Syntax:
        vector<data_type>::iterator iterator_name = vector_name.begin()
        
        Eg: vector<int>::iterator it= v.begin();
            cout<<*(it)<<" ";
            it++;

            [As iterator points to the memory address we need to dereference it in order to access the element present in that memory address. In the above example we are first printing the element present in the it iterator and then incrementing it so that next time we can access the next value present in the vector]

    # Printing a vector using iterators
        
        Eg:
            for(vector<int>::iterator it=v.begin();it!=v.end();it++)
                cout<<*(it)<<" ";

        *auto keyword:

            for(auto it=v.begin();it!=v.end();it++)
                cout<<*(it)<<" ";

            [It automatically assigns the data type saves us the hassle of mentioning it everytime we use an iterator]


        *for each loop:

            for(auto it : v)
                cout<<it<<" ";

            [Here auto directly assigns the datatype of the element present in the vector and hence we do not have to derefernce "it" while printing]


    # Lists

     Key functions:

        *push_back() – to insert an element at the end of the list.
            list<int> li;
            li.push_back(110);
            li.push_back(220);
        
        *push_front() – to insert an element at the front of the list.
            list<int> li;
            li.push_front(110);
            li.push_front(220);

        *sort() – sorts the list in ascending order.
            li.sort();

        [Rest of the functions are same in functionality as vectors]